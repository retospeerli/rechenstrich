<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rechenstrich ‚Äì Aufgaben (ZR 100 / 1000)</title>
<style>
  :root{font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;background:#eef2f7;}
  body{margin:0;min-height:100vh;display:flex;align-items:center;justify-content:center;padding:16px;}
  .app{background:#fff;border-radius:18px;box-shadow:0 10px 30px rgba(0,0,0,.12);padding:18px;max-width:1020px;width:100%;box-sizing:border-box;}
  h1{margin:0 0 6px;text-align:center;font-size:1.55rem;}
  .subtitle{margin:0 0 14px;text-align:center;color:#475569;font-size:.98rem;line-height:1.35rem;}
  .hidden{display:none;}

  .menu{display:flex;gap:14px;justify-content:center;flex-wrap:wrap;margin-top:16px;}
  .bigbtn{border:none;cursor:pointer;background:#2563eb;color:#fff;font-weight:900;font-size:1.25rem;padding:16px 26px;border-radius:14px;box-shadow:0 10px 20px rgba(37,99,235,.25);}
  .bigbtn:hover{background:#1d4ed8;}

  .toprow{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:center;margin:8px 0 12px;}
  .pill{border:1px solid #cbd5e1;border-radius:999px;padding:.35rem .8rem;background:#f8fafc;color:#0f172a;font-weight:900;}
  .btn{border:none;cursor:pointer;border-radius:12px;padding:.65rem 1rem;font-weight:900;font-size:1rem;}
  .btn.primary{background:#2563eb;color:#fff;}
  .btn.primary:hover{background:#1d4ed8;}
  .btn.secondary{background:#e5e7eb;color:#111827;}
  .btn.secondary:hover{background:#d1d5db;}
  .btn:disabled{background:#94a3b8;color:#fff;cursor:not-allowed;}

  .board{background:#f6f6f6;border:3px solid #9aa3ad;border-radius:14px;padding:14px;}
  .eq{font-size:52px;text-align:center;font-weight:500;letter-spacing:1px;margin:8px 0 8px;}
  .line{height:4px;background:#222;opacity:.65;margin:0 auto 10px;max-width:640px;border-radius:999px;}
  svg{width:100%;height:auto;display:block;}

  .actions{display:flex;gap:10px;justify-content:center;align-items:center;flex-wrap:wrap;margin-top:12px;}
  .feedback{min-height:1.4rem;text-align:center;font-weight:900;margin-top:10px;}
  .ok{color:#15803d;}
  .err{color:#b91c1c;}
  .hint{margin-top:8px;text-align:center;color:#64748b;font-size:.92rem;}

  /* Farb-Legende (optional, klein) */
  .legend{display:flex;gap:10px;justify-content:center;flex-wrap:wrap;margin-top:6px;font-size:.9rem;color:#334155;}
  .swatch{display:inline-flex;align-items:center;gap:6px;}
  .dot{width:14px;height:14px;border-radius:4px;display:inline-block;border:2px solid transparent;}
</style>
</head>
<body>
<div class="app">

  <div id="startScreen">
    <h1>Rechenstrich als Aufgabe</h1>
    <p class="subtitle">
      Nur die <b>Startzahl</b> ist schon da.<br>
      Trage <b>Spr√ºnge</b> (mit <b>Vorzeichen</b>), <b>Zwischenresultate</b> und das <b>Endergebnis</b> ein.<br>
      Erst wenn alles ausgef√ºllt ist, kannst du auf <b>√úberpr√ºfen</b> klicken.
    </p>
    <div class="menu">
      <button class="bigbtn" type="button" id="btnZR100">ZR 100</button>
      <button class="bigbtn" type="button" id="btnZR1000">ZR 1000</button>
    </div>
  </div>

  <div id="taskScreen" class="hidden">
    <div class="toprow">
      <span class="pill" id="zrPill">ZR ?</span>
      <span class="pill" id="modePill">‚Äî</span>
      <span class="pill" id="progressPill">0 / 20</span>
      <button class="btn secondary" type="button" id="btnNew">Neue Aufgabe</button>
      <button class="btn secondary" type="button" id="btnBack">Zur√ºck</button>
    </div>

    <div class="board">
      <div class="eq" id="eqText">‚Äî</div>
      <div class="line"></div>
      <svg id="svg" viewBox="0 0 920 300" aria-label="Rechenstrich-Aufgabe"></svg>

      <div class="legend" aria-label="Farblegende">
        <span class="swatch"><span class="dot" style="border-color:#16a34a;background:rgba(22,163,74,.18)"></span>1. Zwischenresultat</span>
        <span class="swatch"><span class="dot" style="border-color:#2563eb;background:rgba(37,99,235,.18)"></span>letztes Zwischenresultat</span>
        <span class="swatch"><span class="dot" style="border-color:#dc2626;background:rgba(220,38,38,.18)"></span>Endergebnis</span>
      </div>

      <div class="actions">
        <button class="btn primary" id="checkBtn" type="button" disabled>√úberpr√ºfen</button>
        <button class="btn secondary" id="clearBtn" type="button">Eingaben l√∂schen</button>
      </div>

      <div class="feedback" id="feedback"></div>
      <div class="hint" id="hintText">‚Äî</div>
    </div>
  </div>

  <audio id="snd-correct" src="audio/correct.wav" preload="auto"></audio>
  <audio id="snd-error"   src="audio/error.wav" preload="auto"></audio>
  <audio id="snd-won"     src="audio/gamewon.wav" preload="auto"></audio>

</div>

<script>
/* ======================= DOM / State ======================= */
const svg = document.getElementById("svg");
const eqText = document.getElementById("eqText");
const feedback = document.getElementById("feedback");
const hintText = document.getElementById("hintText");

const checkBtn = document.getElementById("checkBtn");
const clearBtn = document.getElementById("clearBtn");

const zrPill = document.getElementById("zrPill");
const modePill = document.getElementById("modePill");
const progressPill = document.getElementById("progressPill");

const btnZR100 = document.getElementById("btnZR100");
const btnZR1000 = document.getElementById("btnZR1000");
const btnNew = document.getElementById("btnNew");
const btnBack = document.getElementById("btnBack");

const sndCorrect = document.getElementById("snd-correct");
const sndError   = document.getElementById("snd-error");
const sndWon     = document.getElementById("snd-won");

let ZR = 100;
let solvedCorrect = 0;
let task = null;
let inputs = [];
let audioPrimed = false;

/* ======================= Farben Plan B ======================= */
/*
  Vorgabe:
  - Endergebnis: rot
  - letztes Zwischenresultat: blau
  - erstes Zwischenresultat: gr√ºn
  Alle anderen: neutral (grau)
*/
const COLOR = {
  neutral: { stroke:"#222", box:"#94a3b8", fill:"rgba(148,163,184,.14)" },
  first:   { stroke:"#16a34a", box:"#16a34a", fill:"rgba(22,163,74,.18)"  }, // gr√ºn
  last:    { stroke:"#2563eb", box:"#2563eb", fill:"rgba(37,99,235,.18)"  }, // blau
  final:   { stroke:"#dc2626", box:"#dc2626", fill:"rgba(220,38,38,.18)"  }  // rot
};

/* ======================= Audio ======================= */
function playSound(a){
  if(!a) return;
  try{
    a.currentTime = 0;
    const p = a.play();
    if(p && typeof p.catch === "function") p.catch(()=>{});
  }catch(e){}
}
function primeAudio(){
  if(audioPrimed) return;
  audioPrimed = true;
  try{
    [sndCorrect,sndError,sndWon].forEach(a=>{
      if(!a) return;
      a.volume = 1;
      a.play().then(()=>{a.pause(); a.currentTime=0;}).catch(()=>{});
    });
  }catch(e){}
}

/* ======================= Navigation ======================= */
btnZR100.addEventListener("click", () => startWithZR(100));
btnZR1000.addEventListener("click", () => startWithZR(1000));
btnNew.addEventListener("click", () => { primeAudio(); newTask(); });
btnBack.addEventListener("click", () => backToMenu());

function startWithZR(zr){
  ZR = zr;
  solvedCorrect = 0;
  primeAudio();

  document.getElementById("startScreen").classList.add("hidden");
  document.getElementById("taskScreen").classList.remove("hidden");

  updateHeader();
  newTask();
}
function backToMenu(){
  document.getElementById("taskScreen").classList.add("hidden");
  document.getElementById("startScreen").classList.remove("hidden");
  feedback.textContent = "";
  feedback.className = "feedback";
}

/* ======================= Generator ======================= */
function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }

function decomposeByZR(unsignedB){
  const n = Math.abs(unsignedB);
  if (ZR === 100){
    const z = Math.floor(n/10)*10;
    const e = n%10;
    return [z,e].filter(x=>x!==0);
  } else {
    const h = Math.floor(n/100)*100;
    const z = Math.floor((n%100)/10)*10;
    const e = n%10;
    return [h,z,e].filter(x=>x!==0);
  }
}

function updateHeader(){
  zrPill.textContent = `ZR ${ZR}`;
  progressPill.textContent = `${solvedCorrect} / 20`;
  modePill.textContent = task ? (task.mode === "add" ? "Addition" : "Subtraktion") : "‚Äî";
  hintText.textContent = (ZR === 100)
    ? "Tipp: Zerlege die zweite Zahl in Z/E (z.B. 47 ‚Üí 40, 7). Spr√ºnge mit Vorzeichen: +40, +7 oder -40, -7."
    : "Tipp: Zerlege die zweite Zahl in H/Z/E (z.B. 238 ‚Üí 200, 30, 8). Spr√ºnge mit Vorzeichen: +200, +30, +8 oder -200, -30, -8.";
}

function newTask(){
  feedback.textContent = "";
  feedback.className = "feedback";
  checkBtn.disabled = true;
  inputs = [];
  clearSvg();

  const mode = (Math.random() < 0.5) ? "add" : "sub";

  const aMin = (ZR === 100) ? 10 : 100;
  const aMax = (ZR === 100) ? 99 : 999;

  let a = 0, b = 0, res = 0;
  for(let tries=0; tries<900; tries++){
    a = randInt(aMin, aMax);
    b = randInt(aMin, aMax);
    res = (mode === "add") ? (a + b) : (a - b);
    if (mode === "add") { if (res <= ZR) break; }
    else { if (res >= 0) break; }
  }

  const partsUnsigned = decomposeByZR(b);
  const partsSigned = partsUnsigned.map(p => mode === "add" ? +p : -p);

  const values = [a];
  let cur = a;
  for(const sp of partsSigned){ cur += sp; values.push(cur); }

  task = { mode, a, b, partsUnsigned, partsSigned, values };

  eqText.textContent = `${a} ${(mode==="add")?"+":"‚àí"} ${b} =`;
  updateHeader();

  drawTaskSVG(task);
  updateCheckEnabled();
  focusFirstEmpty();
}

/* ======================= SVG helpers ======================= */
function el(name, attrs = {}){
  const n = document.createElementNS("http://www.w3.org/2000/svg", name);
  for(const [k,v] of Object.entries(attrs)) n.setAttribute(k, String(v));
  return n;
}
function clearSvg(){ while(svg.firstChild) svg.removeChild(svg.firstChild); }

/* ---------- signed parsing: requires + or - ---------- */
function parseSignedNumber(str){
  const s = (str || "").trim().replace(/\s+/g,"");
  if(!s) return { ok:false, value:NaN };
  if(!/^[+-]\d+$/.test(s)) return { ok:false, value:NaN };
  const v = Number(s);
  return { ok:Number.isFinite(v), value:v };
}

/* ======================= Input in SVG with Color ======================= */
function addSvgInput({x,y,w=120,h=46, placeholder="?", id="", signed=false, expectedSign="+", theme=COLOR.neutral}){
  const fo = el("foreignObject", {x, y, width:w, height:h});
  const div = document.createElement("div");
  div.style.width = "100%";
  div.style.height = "100%";
  div.style.display = "flex";
  div.style.alignItems = "center";
  div.style.justifyContent = "center";

  const inp = document.createElement("input");
  inp.type = signed ? "text" : "number";
  inp.inputMode = "numeric";
  inp.autocomplete = "off";
  inp.placeholder = placeholder;
  inp.id = id;

  if (signed){
    inp.dataset.signed = "1";
    inp.dataset.expectedSign = expectedSign;
    inp.spellcheck = false;
  }

  // Farb-Style (Rahmen voll, Background transparent)
  inp.style.width = "100%";
  inp.style.height = "100%";
  inp.style.boxSizing = "border-box";
  inp.style.border = `3px solid ${theme.box}`;
  inp.style.borderRadius = "10px";
  inp.style.textAlign = "center";
  inp.style.fontSize = "24px";
  inp.style.fontWeight = "900";
  inp.style.background = theme.fill;
  inp.style.color = "#111827";

  inp.addEventListener("input", () => {
    primeAudio();
    feedback.textContent = "";
    feedback.className = "feedback";
    // reset wrong highlight to theme
    inp.style.borderColor = theme.box;
    inp.style.boxShadow = "none";
    updateCheckEnabled();
  });

  // Vorzeichen automatisch erg√§nzen
  inp.addEventListener("blur", () => {
    if(!signed) return;
    const raw = (inp.value || "").trim();
    if(raw === "") return;
    if(/^[+-]/.test(raw)) return;
    if(/^\d+$/.test(raw)){
      inp.value = (inp.dataset.expectedSign || "+") + raw;
    }
  });

  inp.addEventListener("keydown", (e) => {
    if(e.key === "Enter" && !checkBtn.disabled) checkAll();
  });

  // f√ºr sp√§tere Farb-Resets speichern
  inp.dataset.baseBorder = theme.box;

  div.appendChild(inp);
  fo.appendChild(div);
  svg.appendChild(fo);

  inputs.push(inp);
  return inp;
}

/* ======================= drawTaskSVG (Color mapping) ======================= */
function drawTaskSVG(task){
  clearSvg();
  inputs = [];

  const W = 920;
  const baseY = 220;
  const leftPad = 90;
  const rightPad = 90;

  // X-Positionen nach Ratio (1/2/4), volle Breite
  const usableW = W - leftPad - rightPad;
  const weights = task.partsUnsigned.map(p => {
    const ap = Math.abs(p);
    if (ap >= 100) return 4;
    if (ap >= 10) return 2;
    return 1;
  });
  const sumW = weights.reduce((a,b)=>a+b,0) || 1;
  const unit = usableW / sumW;

  const xs = [leftPad];
  for(let i=0;i<weights.length;i++) xs.push(xs[xs.length-1] + weights[i]*unit);
  xs[xs.length-1] = W - rightPad;

  // Grundlinie
  svg.appendChild(el("line", {
    x1:leftPad, y1:baseY, x2:W-rightPad, y2:baseY,
    stroke:"#222", "stroke-width":6, "stroke-linecap":"round", opacity:0.75
  }));

  // Starttick (neutral)
  svg.appendChild(el("line", {
    x1:xs[0], y1:baseY-16, x2:xs[0], y2:baseY+16,
    stroke:"#222", "stroke-width":6, "stroke-linecap":"round", opacity:0.85
  }));

  // Farbzuteilung f√ºr Resultat-Ticks:
  // p1 -> gr√ºn, p(last-1) -> blau, p(last) -> rot
  const m = task.values.length - 1;
  const idxFirst = 1;
  const idxLastIntermediate = (m >= 2) ? (m - 1) : null;  // z.B. bei 2 Schritten: p1 ist zugleich "letztes Zwischenergebnis"
  const idxFinal = m;

  function themeForP(idx){
    if(idx === idxFinal) return COLOR.final;
    if(m === 1) return COLOR.final; // nur ein Ergebnis -> gleich Endergebnis
    if(idx === idxFirst && idx === idxLastIntermediate) return COLOR.last; // Spezial: nur 2 K√§stchen? (m=2) -> p1 ist letztes Zwischenresultat
    if(idx === idxFirst) return COLOR.first;
    if(idxLastIntermediate !== null && idx === idxLastIntermediate) return COLOR.last;
    return COLOR.neutral;
  }

  // Ticks (p1..pN) farbig + neutral sonst
  for(let i=1;i<task.values.length;i++){
    const idx = i; // p idx
    const theme = themeForP(idx);

    svg.appendChild(el("line", {
      x1:xs[i], y1:baseY-16, x2:xs[i], y2:baseY+16,
      stroke:theme.stroke, "stroke-width":7, "stroke-linecap":"round", opacity:0.95
    }));
  }

  // Startzahl
  {
    const t = el("text", {
      x: xs[0], y: baseY + 56,
      "text-anchor":"middle",
      "font-size":44,
      "font-weight":600,
      fill:"#111"
    });
    t.textContent = String(task.values[0]);
    svg.appendChild(t);
  }

  // Resultat-K√§stchen (FARBE!)
  const boxW = 132;
  const boxH = 46;
  const yBox = baseY + 24;

  // Position: direkt zentriert unter Tick (Plan B: Farbe statt perfekte Position)
  // (wir lassen es bewusst einfach ‚Äì keine Kollisionslogik mehr erzwingen)
  for(let i=1;i<task.values.length;i++){
    const idx = i; // p idx
    const theme = themeForP(idx);
    const left = xs[i] - boxW/2;

    addSvgInput({ x:left, y:yBox, w:boxW, h:boxH, placeholder:"?", id:`p${idx}`, signed:false, theme });

    // Doppelunterstrich beim Endergebnis (rot)
    if(idx === idxFinal){
      const cx = left + boxW/2;
      svg.appendChild(el("line", { x1:cx-90, y1:baseY+78, x2:cx+90, y2:baseY+78, stroke:COLOR.final.stroke, "stroke-width":3, opacity:0.95 }));
      svg.appendChild(el("line", { x1:cx-90, y1:baseY+86, x2:cx+90, y2:baseY+86, stroke:COLOR.final.stroke, "stroke-width":3, opacity:0.95 }));
    }
  }

  // B√∂gen + Sprunginputs (neutral, da es um Schrittwerte geht)
  const laneTopY = [ 90, 125, 155, 175 ];
  const arcTopY  = [ 150, 170, 185, 195 ];
  const arcStroke = "#555";
  const arcWidth = 4;

  const expectedSign = (task.mode === "add") ? "+" : "-";

  for(let i=0;i<task.partsSigned.length;i++){
    const x1 = xs[i];
    const x2 = xs[i+1];
    const mx = (x1 + x2)/2;

    const topY = arcTopY[Math.min(i, arcTopY.length-1)];
    const d = `M ${x1} ${baseY} Q ${mx} ${topY} ${x2} ${baseY}`;
    svg.appendChild(el("path", { d, fill:"none", stroke:arcStroke, "stroke-width":arcWidth, "stroke-linecap":"round" }));

    const iy = laneTopY[Math.min(i, laneTopY.length-1)];
    addSvgInput({
      x: mx-48, y: iy, w: 96, h: 44,
      placeholder: expectedSign + "?",
      id: `jump${i}`,
      signed: true,
      expectedSign,
      theme: COLOR.neutral
    });
  }

  // Controls
  checkBtn.onclick = checkAll;

  clearBtn.onclick = () => {
    primeAudio();
    inputs.forEach(i=>{
      i.value = "";
      i.disabled = false;
      // zur√ºck auf Basisfarbe
      const base = i.dataset.baseBorder || "#94a3b8";
      i.style.borderColor = base;
      i.style.boxShadow = "none";
    });
    feedback.textContent = "";
    feedback.className = "feedback";
    updateCheckEnabled();
    focusFirstEmpty();
  };
}

/* ======================= Check / LV ======================= */
function markWrong(inp){
  inp.style.borderColor = "#b91c1c";
  inp.style.boxShadow = "0 0 0 3px rgba(185,28,28,.18)";
}
function resetMark(inp){
  const base = inp.dataset.baseBorder || "#94a3b8";
  inp.style.borderColor = base;
  inp.style.boxShadow = "none";
}

function checkAll(){
  primeAudio();
  inputs.forEach(resetMark);

  const wrong = [];

  for(let i=0;i<task.partsSigned.length;i++){
    const inp = document.getElementById(`jump${i}`);
    const parsed = parseSignedNumber(inp.value);
    if(!parsed.ok || parsed.value !== task.partsSigned[i]) wrong.push(inp);
  }

  for(let i=1;i<task.values.length;i++){
    const inp = document.getElementById(`p${i}`);
    const given = Number(inp.value);
    if(!Number.isFinite(given) || given !== task.values[i]) wrong.push(inp);
  }

  if(wrong.length === 0){
    playSound(sndCorrect);
    feedback.textContent = "Alles richtig! ‚úÖ";
    feedback.className = "feedback ok";

    solvedCorrect++;
    updateHeader();

    if(solvedCorrect >= 20){
      setTimeout(()=>playSound(sndWon), 200);
      try{
        if(window.parent && window.parent !== window){
          window.parent.postMessage("AppSolved","*");
        }
      }catch(e){}
      inputs.forEach(i => i.disabled = true);
      checkBtn.disabled = true;
      setTimeout(()=>{
        feedback.textContent = "20 Aufgaben richtig gel√∂st! üéâ";
        feedback.className = "feedback ok";
      }, 220);
      return;
    }
    setTimeout(newTask, 650);
  } else {
    playSound(sndError);
    feedback.textContent = "Noch nicht ganz ‚Äì rote Felder korrigieren und erneut pr√ºfen.";
    feedback.className = "feedback err";
    wrong.forEach(markWrong);
    wrong[0].focus();
  }
}

/* ======================= Enable check ======================= */
function updateCheckEnabled(){
  const allFilled = inputs.length > 0 && inputs.every(i => (i.value || "").trim() !== "");
  checkBtn.disabled = !allFilled;
}
function focusFirstEmpty(){
  const f = inputs.find(i => (i.value || "").trim() === "");
  if(f) f.focus();
}

/* ======================= Start ======================= */
updateHeader();
</script>
</body>
</html>
