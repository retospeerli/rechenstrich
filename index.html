<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rechenstrich â€“ Aufgaben (ZR 100 / 1000)</title>
<style>
  :root{
    font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
    background:#eef2f7;
  }
  body{margin:0;min-height:100vh;display:flex;align-items:center;justify-content:center;padding:16px;}
  .app{background:#fff;border-radius:18px;box-shadow:0 10px 30px rgba(0,0,0,.12);padding:18px;max-width:1020px;width:100%;box-sizing:border-box;}
  h1{margin:0 0 6px;text-align:center;font-size:1.55rem;}
  .subtitle{margin:0 0 14px;text-align:center;color:#475569;font-size:.98rem;line-height:1.35rem;}
  .hidden{display:none;}

  .menu{display:flex;gap:14px;justify-content:center;flex-wrap:wrap;margin-top:16px;}
  .bigbtn{
    border:none;cursor:pointer;
    background:#2563eb;color:#fff;
    font-weight:900;font-size:1.25rem;
    padding:16px 26px;border-radius:14px;
    box-shadow:0 10px 20px rgba(37,99,235,.25);
  }
  .bigbtn:hover{background:#1d4ed8;}

  .toprow{
    display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:center;
    margin:8px 0 12px;
  }
  .pill{
    border:1px solid #cbd5e1;border-radius:999px;padding:.35rem .8rem;
    background:#f8fafc;color:#0f172a;font-weight:900;
  }
  .btn{
    border:none;cursor:pointer;border-radius:12px;
    padding:.65rem 1rem;font-weight:900;font-size:1rem;
  }
  .btn.primary{background:#2563eb;color:#fff;}
  .btn.primary:hover{background:#1d4ed8;}
  .btn.secondary{background:#e5e7eb;color:#111827;}
  .btn.secondary:hover{background:#d1d5db;}
  .btn:disabled{background:#94a3b8;color:#fff;cursor:not-allowed;}

  .board{
    background:#f6f6f6;
    border:3px solid #9aa3ad;
    border-radius:14px;
    padding:14px;
  }
  .eq{font-size:52px;text-align:center;font-weight:500;letter-spacing:1px;margin:8px 0 8px;}
  .line{height:4px;background:#222;opacity:.65;margin:0 auto 10px;max-width:640px;border-radius:999px;}
  svg{width:100%;height:auto;display:block;}

  .actions{display:flex;gap:10px;justify-content:center;align-items:center;flex-wrap:wrap;margin-top:12px;}
  .feedback{min-height:1.4rem;text-align:center;font-weight:900;margin-top:10px;}
  .ok{color:#15803d;}
  .err{color:#b91c1c;}
  .hint{margin-top:8px;text-align:center;color:#64748b;font-size:.92rem;}
</style>
</head>
<body>
<div class="app">

  <!-- START -->
  <div id="startScreen">
    <h1>Rechenstrich als Aufgabe</h1>
    <p class="subtitle">
      Nur die <b>Startzahl</b> ist schon da.<br>
      Trage <b>SprÃ¼nge</b> (mit <b>Vorzeichen</b>), <b>Zwischenresultate</b> und das <b>Endergebnis</b> ein.<br>
      Erst wenn alles ausgefÃ¼llt ist, kannst du auf <b>ÃœberprÃ¼fen</b> klicken.
    </p>
    <div class="menu">
      <button class="bigbtn" type="button" id="btnZR100">ZR 100</button>
      <button class="bigbtn" type="button" id="btnZR1000">ZR 1000</button>
    </div>
  </div>

  <!-- TASK -->
  <div id="taskScreen" class="hidden">
    <div class="toprow">
      <span class="pill" id="zrPill">ZR ?</span>
      <span class="pill" id="modePill">â€”</span>
      <span class="pill" id="progressPill">0 / 20</span>
      <button class="btn secondary" type="button" id="btnNew">Neue Aufgabe</button>
      <button class="btn secondary" type="button" id="btnBack">ZurÃ¼ck</button>
    </div>

    <div class="board">
      <div class="eq" id="eqText">â€”</div>
      <div class="line"></div>

      <!-- viewBox-HÃ¶he wird dynamisch angepasst, wenn 2 Zeilen nÃ¶tig sind -->
      <svg id="svg" viewBox="0 0 920 290" aria-label="Rechenstrich-Aufgabe"></svg>

      <div class="actions">
        <button class="btn primary" id="checkBtn" type="button" disabled>ÃœberprÃ¼fen</button>
        <button class="btn secondary" id="clearBtn" type="button">Eingaben lÃ¶schen</button>
      </div>

      <div class="feedback" id="feedback"></div>
      <div class="hint" id="hintText">â€”</div>
    </div>
  </div>

  <!-- Audio (Repo: ./audio/) -->
  <audio id="snd-correct" src="audio/correct.wav" preload="auto"></audio>
  <audio id="snd-error"   src="audio/error.wav" preload="auto"></audio>
  <audio id="snd-won"     src="audio/gamewon.wav" preload="auto"></audio>

</div>

<script>
/* ======================= DOM / State ======================= */
const svg = document.getElementById("svg");
const eqText = document.getElementById("eqText");
const feedback = document.getElementById("feedback");
const hintText = document.getElementById("hintText");

const checkBtn = document.getElementById("checkBtn");
const clearBtn = document.getElementById("clearBtn");

const zrPill = document.getElementById("zrPill");
const modePill = document.getElementById("modePill");
const progressPill = document.getElementById("progressPill");

const btnZR100 = document.getElementById("btnZR100");
const btnZR1000 = document.getElementById("btnZR1000");
const btnNew = document.getElementById("btnNew");
const btnBack = document.getElementById("btnBack");

const sndCorrect = document.getElementById("snd-correct");
const sndError   = document.getElementById("snd-error");
const sndWon     = document.getElementById("snd-won");

let ZR = 100;
let solvedCorrect = 0;         // 0..20 (nur vollstÃ¤ndig richtige Aufgaben)
let task = null;               // {mode,a,b,partsUnsigned,partsSigned,values}
let inputs = [];               // alle Inputs (SprÃ¼nge + Resultate)
let audioPrimed = false;

/* ======================= Audio ======================= */
function playSound(a){
  if(!a) return;
  try{
    a.currentTime = 0;
    const p = a.play();
    if(p && typeof p.catch === "function") p.catch(()=>{});
  }catch(e){}
}
function primeAudio(){
  if(audioPrimed) return;
  audioPrimed = true;
  try{
    [sndCorrect,sndError,sndWon].forEach(a=>{
      if(!a) return;
      a.volume = 1;
      a.play().then(()=>{a.pause(); a.currentTime=0;}).catch(()=>{});
    });
  }catch(e){}
}

/* ======================= Navigation ======================= */
btnZR100.addEventListener("click", () => startWithZR(100));
btnZR1000.addEventListener("click", () => startWithZR(1000));
btnNew.addEventListener("click", () => { primeAudio(); newTask(); });
btnBack.addEventListener("click", () => backToMenu());

function startWithZR(zr){
  ZR = zr;
  solvedCorrect = 0;
  primeAudio();

  document.getElementById("startScreen").classList.add("hidden");
  document.getElementById("taskScreen").classList.remove("hidden");

  updateHeader();
  newTask();
}
function backToMenu(){
  document.getElementById("taskScreen").classList.add("hidden");
  document.getElementById("startScreen").classList.remove("hidden");
  feedback.textContent = "";
  feedback.className = "feedback";
}

/* ======================= Generator ======================= */
function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }

function decomposeByZR(unsignedB){
  // ZR100: Z/E; ZR1000: H/Z/E
  const n = Math.abs(unsignedB);
  if (ZR === 100){
    const z = Math.floor(n/10)*10;
    const e = n%10;
    return [z,e].filter(x=>x!==0);
  } else {
    const h = Math.floor(n/100)*100;
    const z = Math.floor((n%100)/10)*10;
    const e = n%10;
    return [h,z,e].filter(x=>x!==0);
  }
}

function updateHeader(){
  zrPill.textContent = `ZR ${ZR}`;
  progressPill.textContent = `${solvedCorrect} / 20`;
  modePill.textContent = task ? (task.mode === "add" ? "Addition" : "Subtraktion") : "â€”";
  hintText.textContent = (ZR === 100)
    ? "Tipp: Zerlege die zweite Zahl in Z/E (z.B. 47 â†’ 40, 7). SprÃ¼nge mit Vorzeichen: +40, +7 oder -40, -7."
    : "Tipp: Zerlege die zweite Zahl in H/Z/E (z.B. 238 â†’ 200, 30, 8). SprÃ¼nge mit Vorzeichen: +200, +30, +8 oder -200, -30, -8.";
}

function newTask(){
  feedback.textContent = "";
  feedback.className = "feedback";
  checkBtn.disabled = true;
  inputs = [];
  clearSvg();

  const mode = (Math.random() < 0.5) ? "add" : "sub";

  // Zahlen wÃ¤hlen: Ergebnis muss im Zahlenraum bleiben
  const aMin = (ZR === 100) ? 10 : 100;
  const aMax = (ZR === 100) ? 99 : 999;

  let a = 0, b = 0, res = 0;
  for(let tries=0; tries<900; tries++){
    a = randInt(aMin, aMax);
    b = randInt(aMin, aMax);
    res = (mode === "add") ? (a + b) : (a - b);
    if (mode === "add") {
      if (res <= ZR) break;
    } else {
      if (res >= 0) break;
    }
  }

  const partsUnsigned = decomposeByZR(b);
  const partsSigned = partsUnsigned.map(p => mode === "add" ? +p : -p);

  const values = [a];
  let cur = a;
  for(const sp of partsSigned){
    cur += sp;
    values.push(cur);
  }

  task = { mode, a, b, partsUnsigned, partsSigned, values };

  eqText.textContent = `${a} ${(mode==="add")?"+":"âˆ’"} ${b} =`;
  updateHeader();

  drawTaskSVG(task);
  updateCheckEnabled();
  focusFirstEmpty();
}

/* ======================= SVG helpers ======================= */
function el(name, attrs = {}){
  const n = document.createElementNS("http://www.w3.org/2000/svg", name);
  for(const [k,v] of Object.entries(attrs)) n.setAttribute(k, String(v));
  return n;
}
function clearSvg(){ while(svg.firstChild) svg.removeChild(svg.firstChild); }

/* ---------- signed parsing: requires + or - ---------- */
function parseSignedNumber(str){
  const s = (str || "").trim().replace(/\s+/g,"");
  if(!s) return { ok:false, value:NaN };
  if(!/^[+-]\d+$/.test(s)) return { ok:false, value:NaN };
  const v = Number(s);
  return { ok:Number.isFinite(v), value:v };
}

/* ---------- input in SVG ---------- */
function addSvgInput({x,y,w=90,h=44, placeholder="?", id="", signed=false, expectedSign="+"}){
  const fo = el("foreignObject", {x, y, width:w, height:h});
  const div = document.createElement("div");
  div.style.width = "100%";
  div.style.height = "100%";
  div.style.display = "flex";
  div.style.alignItems = "center";
  div.style.justifyContent = "center";

  const inp = document.createElement("input");
  inp.type = signed ? "text" : "number";
  inp.inputMode = "numeric";
  inp.autocomplete = "off";
  inp.placeholder = placeholder;
  inp.id = id;

  if (signed){
    inp.dataset.signed = "1";
    inp.dataset.expectedSign = expectedSign;
    inp.spellcheck = false;
  }

  inp.style.width = "100%";
  inp.style.height = "100%";
  inp.style.boxSizing = "border-box";
  inp.style.border = "2px solid #94a3b8";
  inp.style.borderRadius = "10px";
  inp.style.textAlign = "center";
  inp.style.fontSize = "24px";
  inp.style.fontWeight = "900";
  inp.style.background = "#fff";
  inp.style.color = "#111827";

  inp.addEventListener("input", () => {
    primeAudio();
    feedback.textContent = "";
    feedback.className = "feedback";
    inp.style.borderColor = "#94a3b8";
    inp.style.boxShadow = "none";
    updateCheckEnabled();
  });

  // Vorzeichen automatisch ergÃ¤nzen bei SprÃ¼ngen
  inp.addEventListener("blur", () => {
    if(!signed) return;
    const raw = (inp.value || "").trim();
    if(raw === "") return;
    if(/^[+-]/.test(raw)) return;
    if(/^\d+$/.test(raw)){
      inp.value = (inp.dataset.expectedSign || "+") + raw;
    }
  });

  inp.addEventListener("keydown", (e) => {
    if(e.key === "Enter" && !checkBtn.disabled) checkAll();
  });

  div.appendChild(inp);
  fo.appendChild(div);
  svg.appendChild(fo);

  inputs.push(inp);
  return inp;
}

function updateCheckEnabled(){
  const allFilled = inputs.length > 0 && inputs.every(i => (i.value || "").trim() !== "");
  checkBtn.disabled = !allFilled;
}
function focusFirstEmpty(){
  const f = inputs.find(i => (i.value || "").trim() === "");
  if(f) f.focus();
}

/* ======================= drawTaskSVG (NO OVERLAP GUARANTEE) ======================= */
function drawTaskSVG(task){
  clearSvg();
  inputs = [];

  // StandardhÃ¶he; wird ggf. auf 2 Zeilen erhÃ¶ht
  let vbH = 290;

  const W = 920;
  const baseY = 220;
  const leftPad = 90;
  const rightPad = 90;

  // X-Positionen nach Ratio (1/2/4), volle Breite
  const usableW = W - leftPad - rightPad;
  const weights = task.partsUnsigned.map(p => {
    const ap = Math.abs(p);
    if (ap >= 100) return 4;
    if (ap >= 10) return 2;
    return 1;
  });
  const sumW = weights.reduce((a,b)=>a+b,0) || 1;
  const unit = usableW / sumW;

  const xs = [leftPad];
  for(let i=0;i<weights.length;i++) xs.push(xs[xs.length-1] + weights[i]*unit);
  xs[xs.length-1] = W - rightPad;

  // Grundlinie
  svg.appendChild(el("line", {
    x1:leftPad, y1:baseY, x2:W-rightPad, y2:baseY,
    stroke:"#222", "stroke-width":6, "stroke-linecap":"round", opacity:0.75
  }));

  // Ticks
  for(let i=0;i<task.values.length;i++){
    const x = xs[i];
    svg.appendChild(el("line", {
      x1:x, y1:baseY-16, x2:x, y2:baseY+16,
      stroke:"#222", "stroke-width":6, "stroke-linecap":"round", opacity:0.85
    }));
  }

  // Startzahl
  {
    const x = xs[0];
    const t = el("text", {
      x, y: baseY + 56,
      "text-anchor":"middle",
      "font-size":44,
      "font-weight":600,
      fill:"#111"
    });
    t.textContent = String(task.values[0]);
    svg.appendChild(t);
  }

  // ---------- Zwischenresultate/Endresultat: harte Constraints + 2-Zeilen-Failsafe
  const boxW = 116;
  const boxH = 46;

  const yRow1 = baseY + 24;
  const yRow2 = baseY + 24 + 56;

  const gap = 16; // MINIMALABSTAND (sicher)
  const minLeft = leftPad - 10;
  const maxLeft = (W - rightPad) - boxW + 10;

  const m = task.values.length - 1; // p1..pN
  const desired = new Array(m);

  for (let i = 0; i < m; i++){
    desired[i] = xs[i + 1] - boxW / 2;
  }

  function hasOverlap(lefts){
    for(let i=1;i<lefts.length;i++){
      if(lefts[i] < lefts[i-1] + boxW + gap) return true;
    }
    return false;
  }

  function solveRow(desiredLefts){
    const lefts = desiredLefts.slice();

    // clamp
    for(let i=0;i<lefts.length;i++){
      lefts[i] = Math.max(minLeft, Math.min(maxLeft, lefts[i]));
    }

    // right-to-left: hard max distance
    lefts[lefts.length-1] = Math.max(minLeft, Math.min(maxLeft, lefts[lefts.length-1]));
    for(let i=lefts.length-2;i>=0;i--){
      const maxAllowed = lefts[i+1] - (boxW + gap);
      lefts[i] = Math.min(lefts[i], maxAllowed);
      lefts[i] = Math.max(minLeft, lefts[i]);
    }

    // shift right if left too small
    const under = minLeft - lefts[0];
    if(under > 0){
      for(let i=0;i<lefts.length;i++) lefts[i] += under;
    }

    // left-to-right: hard min distance
    for(let i=1;i<lefts.length;i++){
      const minAllowed = lefts[i-1] + boxW + gap;
      if(lefts[i] < minAllowed) lefts[i] = minAllowed;
    }

    // shift left if right overflow
    const overflow = lefts[lefts.length-1] - maxLeft;
    if(overflow > 0){
      for(let i=0;i<lefts.length;i++) lefts[i] -= overflow;
    }

    // final clamp + repair
    for(let i=0;i<lefts.length;i++){
      lefts[i] = Math.max(minLeft, Math.min(maxLeft, lefts[i]));
    }
    for(let i=1;i<lefts.length;i++){
      const minAllowed = lefts[i-1] + boxW + gap;
      if(lefts[i] < minAllowed) lefts[i] = minAllowed;
    }

    return lefts;
  }

  // 1 Zeile versuchen
  let leftsRow1 = solveRow(desired);
  let useTwoRows = hasOverlap(leftsRow1);

  let splitIndex = m;
  let row1 = [];
  let row2 = [];
  let lefts2a = null;
  let lefts2b = null;

  if(useTwoRows){
    // zweite Reihe nimmt standardmÃ¤ssig die letzten 2 KÃ¤stchen
    splitIndex = Math.max(1, m - 2);
    row1 = desired.slice(0, splitIndex);
    row2 = desired.slice(splitIndex);

    lefts2a = solveRow(row1);
    lefts2b = solveRow(row2);

    // falls immer noch problematisch (theoretisch), noch aggressiver splitten
    if(hasOverlap(lefts2a) || hasOverlap(lefts2b)){
      splitIndex = Math.max(1, m - 1);
      row1 = desired.slice(0, splitIndex);
      row2 = desired.slice(splitIndex);
      lefts2a = solveRow(row1);
      lefts2b = solveRow(row2);
    }

    vbH = 350; // mehr HÃ¶he, damit Zeile 2 nicht abgeschnitten wird
  }

  // viewBox anpassen
  svg.setAttribute("viewBox", `0 0 920 ${vbH}`);

  // Zeichnen
  if(!useTwoRows){
    for (let i = 0; i < m; i++){
      const idx = i + 1;
      const left = leftsRow1[i];

      addSvgInput({ x:left, y:yRow1, w:boxW, h:boxH, placeholder:"?", id:`p${idx}`, signed:false });

      if(idx === task.values.length - 1){
        const cx = left + boxW/2;
        svg.appendChild(el("line", { x1:cx-78, y1:baseY+78, x2:cx+78, y2:baseY+78, stroke:"#111", "stroke-width":3, opacity:0.9 }));
        svg.appendChild(el("line", { x1:cx-78, y1:baseY+86, x2:cx+78, y2:baseY+86, stroke:"#111", "stroke-width":3, opacity:0.9 }));
      }
    }
  } else {
    // Reihe 1
    for(let i=0;i<row1.length;i++){
      const idx = i + 1;
      const left = lefts2a[i];
      addSvgInput({ x:left, y:yRow1, w:boxW, h:boxH, placeholder:"?", id:`p${idx}`, signed:false });
    }
    // Reihe 2
    for(let j=0;j<row2.length;j++){
      const idx = splitIndex + j + 1;
      const left = lefts2b[j];
      addSvgInput({ x:left, y:yRow2, w:boxW, h:boxH, placeholder:"?", id:`p${idx}`, signed:false });

      if(idx === task.values.length - 1){
        const cx = left + boxW/2;
        svg.appendChild(el("line", { x1:cx-78, y1:baseY+78, x2:cx+78, y2:baseY+78, stroke:"#111", "stroke-width":3, opacity:0.9 }));
        svg.appendChild(el("line", { x1:cx-78, y1:baseY+86, x2:cx+78, y2:baseY+86, stroke:"#111", "stroke-width":3, opacity:0.9 }));
      }
    }
  }

  // ---------- BÃ¶gen + Sprunginputs (Vorzeichen Pflicht)
  const laneTopY = [ 90, 125, 155, 175 ];
  const arcTopY  = [ 150, 170, 185, 195 ];
  const arcStroke = "#555";
  const arcWidth = 4;

  const expectedSign = (task.mode === "add") ? "+" : "-";

  for(let i=0;i<task.partsSigned.length;i++){
    const x1 = xs[i];
    const x2 = xs[i+1];
    const mx = (x1 + x2)/2;

    const topY = arcTopY[Math.min(i, arcTopY.length-1)];
    const d = `M ${x1} ${baseY} Q ${mx} ${topY} ${x2} ${baseY}`;
    svg.appendChild(el("path", { d, fill:"none", stroke:arcStroke, "stroke-width":arcWidth, "stroke-linecap":"round" }));

    const iy = laneTopY[Math.min(i, laneTopY.length-1)];
    addSvgInput({
      x: mx-48, y: iy, w: 96, h: 44,
      placeholder: expectedSign + "?",
      id: `jump${i}`,
      signed: true,
      expectedSign
    });
  }

  // Controls
  checkBtn.onclick = checkAll;

  clearBtn.onclick = () => {
    primeAudio();
    inputs.forEach(i=>{
      i.value = "";
      i.disabled = false;
      i.style.borderColor = "#94a3b8";
      i.style.boxShadow = "none";
    });
    feedback.textContent = "";
    feedback.className = "feedback";
    updateCheckEnabled();
    focusFirstEmpty();
  };
}

/* ======================= Check / Progress / LearningView ======================= */
function markWrong(inp){
  inp.style.borderColor = "#b91c1c";
  inp.style.boxShadow = "0 0 0 3px rgba(185,28,28,.18)";
}
function resetMark(inp){
  inp.style.borderColor = "#94a3b8";
  inp.style.boxShadow = "none";
}

checkBtn.addEventListener("click", () => checkAll());

function checkAll(){
  primeAudio();
  inputs.forEach(resetMark);

  const wrong = [];

  // SprÃ¼nge prÃ¼fen: +/âˆ’ Pflicht
  for(let i=0;i<task.partsSigned.length;i++){
    const inp = document.getElementById(`jump${i}`);
    const parsed = parseSignedNumber(inp.value);
    if(!parsed.ok || parsed.value !== task.partsSigned[i]) wrong.push(inp);
  }

  // Zwischenresultate prÃ¼fen
  for(let i=1;i<task.values.length;i++){
    const inp = document.getElementById(`p${i}`);
    const given = Number(inp.value);
    if(!Number.isFinite(given) || given !== task.values[i]) wrong.push(inp);
  }

  if(wrong.length === 0){
    playSound(sndCorrect);
    feedback.textContent = "Alles richtig! âœ…";
    feedback.className = "feedback ok";

    solvedCorrect++;
    updateHeader();

    if(solvedCorrect >= 20){
      setTimeout(()=>playSound(sndWon), 200);

      try{
        if(window.parent && window.parent !== window){
          window.parent.postMessage("AppSolved","*");
        }
      }catch(e){}

      inputs.forEach(i => i.disabled = true);
      checkBtn.disabled = true;

      setTimeout(()=>{
        feedback.textContent = "20 Aufgaben richtig gelÃ¶st! ðŸŽ‰";
        feedback.className = "feedback ok";
      }, 220);

      return;
    }

    setTimeout(newTask, 650);

  } else {
    playSound(sndError);
    feedback.textContent = "Noch nicht ganz â€“ rote Felder korrigieren und erneut prÃ¼fen.";
    feedback.className = "feedback err";
    wrong.forEach(markWrong);
    wrong[0].focus();
  }
}
</script>
</body>
</html>
